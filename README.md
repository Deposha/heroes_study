# heroes_study

# Реализованные алгоритмы

Репозиторий содержит реализации программных модулей (package `programs`) для симуляции боя и вспомогательных задач:

- GeneratePresetImpl - генерация армии на заданное число очков.
- SimulateBattleImpl — симуляция боя между двумя армиями.
- SuitableForAttackUnitsFinderImpl — поиск «подходящих» юнитов для атаки по линиям/колонкам.
- UnitTargetPathFinderImpl — поиск пути к цели на сетке (pathfinding).

Ниже — какие алгоритмы использованы и как оценена их сложность.

---

## 1) GeneratePresetImpl — генерация пресета армии (жадный алгоритм)

### Что делает
1. Копирует список доступных шаблонов юнитов.
2. Сортирует их по «эффективности» (компаратор):
   - сначала по `baseAttack / cost` (по убыванию),
   - затем по `health / cost` (по убыванию),
   - затем по `cost` (по возрастанию),
   - затем по `unitType` (лексикографически).
3. Генерирует список клеток размещения слева (фиксированная зона `x ∈ [0..2]`, `y ∈ [0..20]`) и перемешивает их.
4. Дальше **жадно** добавляет юнитов:
   - каждый раз ищет "лучший" (первый в отсортированном списке), который:
     - стоит не дороже оставшихся очков,
     - не превышает лимит `MAX_UNITS_PER_TYPE = 11` для своего типа,
     - имеет корректную стоимость.
   - клонирует юнит (копируя бонусы атаки/защиты), ставит в очередную свободную клетку, уменьшает очки, увеличивает счётчик типа.
5. Останавливается, когда:
   - не осталось подходящих юнитов по очкам/лимитам, или
   - закончились клетки размещения.

### Сложность
Обозначения:
- `n` — количество доступных «шаблонов» юнитов во входном списке.
- `k` — количество созданных юнитов в армии (ограничено числом клеток).  
  Здесь `k ≤ 3 * 21 = 63` (константа).

Оценка:
- Сортировка шаблонов: **O(n log n)**.
- Основной цикл подбора: в худшем случае на каждое добавление юнита делается линейный проход по списку шаблонов → **O(k · n)**.
- Генерация клеток размещения: `63` операций → **O(1)**.
- Итого: **O(n log n + k·n)**, а с учётом `k ≤ 63` на этой карте — практически **O(n log n)**.

Память:
- Доп. структуры: список клеток (63), счётчики типов, результат → **O(n + k)** (по сути доминирует копия списка `n`).

---

## 2) `SuitableForAttackUnitsFinderImpl` — выбор подходящих юнитов (линейный проход)

### Что делает
Вход: `List<List<Unit>>` (набор «линий»/групп юнитов) и флаг направления.

Для каждой внутренней коллекции:
- пропускает `null` и «мертвых» юнитов (health ≤ 0 или `isAlive == false`);
- выбирает один юнит с экстремальным `yCoordinate`:
  - если флаг `true` → берёт с **максимальным** `y`,
  - если флаг `false` → берёт с **минимальным** `y`;
- добавляет выбранного в результирующий список.

Это фактически «сканирование» каждой группы с выбором минимума/максимума.

### Сложность
- Пусть `M` — общее число элементов во всех списках (суммарное количество юнитов во входной структуре).
- Тогда алгоритм делает один проход по каждому элементу → **O(M)**.
- Память: результат хранит по одному юниту на группу → **O(G)**, где `G` — число групп (внешний список).

---

## 3) `UnitTargetPathFinderImpl` — поиск пути (A\* на сетке 27×21)

### Что делает
Ищет путь от атакующего юнита к целевому юниту на фиксированной сетке:

- Размер поля: `WIDTH = 27`, `HEIGHT = 21`.
- Движение: 8 направлений (включая диагонали) — массивы `DX/DY`.
- Сначала строит матрицу препятствий `blocked[x][y]` по списку юнитов:
  - препятствиями считаются **живые** юниты с `health > 0`, кроме стартового и целевого.
- Далее запускает **A\***:
  - `g` — стоимость пути от старта (шаг = 1),
  - `h` — эвристика **Chebyshev distance** до цели,
  - `f = g + h`,
  - в `PriorityQueue` узлы упорядочены по `f`, затем по `h`, затем по `dev`.
- `dev` — дополнительный тай-брейкер («отклонение» от прямой к цели), чтобы стабилизировать выбор при равных `f/h`.
- Хранит `dist` и родителей (`parentX/parentY`) и восстанавливает путь от цели к старту.

### Сложность
Обозначения:
- `V = WIDTH * HEIGHT = 27 * 21 = 567` — число клеток (вершин графа).
- `E` — число рёбер; при 8-соседстве `E = O(V)`.

Оценка:
- Построение препятствий по списку юнитов размера `u`: **O(u)**.
- A\* на решётке с очередью: **O((V + E) log V)** ⇒ **O(V log V)**.
- На данной карте `V = 567` — константа, поэтому по факту это очень быстро, но формально:
  - **O(u + V log V)**.

Память:
- Матрицы `dist/parent/visited/blocked`: **O(V)**.

---

## 4) `SimulateBattleImpl` — симуляция боя (циклы раундов + сортировка порядка ходов)

### Что делает
- Проводит до `MAX_ROUNDS = 10000` итераций (раундов), но обычно выходит раньше.
- На каждом раунде:
  1. `cleanup(army)` — удаляет из списков юнитов `null` и «мертвых».
  2. `isDefeated(army)` — проверяет, остались ли живые (через `stream().noneMatch(...)`).
  3. `buildTurnOrder(a, b)` — объединяет юнитов обеих армий в один список, удаляет мёртвых и **сортирует**:
     - ключи сортировки: сначала по одному целочисленному параметру (с `reversed()`), затем по строковым/доп. полям с `nullsLast()` (точные поля зависят от `Unit`, но сортировка многоступенчатая).
  4. Идёт по `turnOrder`: каждый живой юнит вызывает `unit.getProgram().attack()`.
  5. Если включён `printBattleLog`, печатает действие.
- Ранний выход:
  - если одна из армий побеждена,
  - если за полный проход не было «реальных» атак (цель `null` или юнит атакует сам себя) — чтобы не зациклиться.

### Сложность
Обозначения:
- `U = |army1| + |army2|` — суммарное число юнитов, участвующих в раунде.
- `R` — число раундов (≤ 10000).
- `A` — стоимость одного `attack()` (внутренняя логика чужого `Program`, зависит от реализации).

Пер-раунд:
- `cleanup` — линейная фильтрация списка: **O(U)**.
- `isDefeated` — линейный проход: **O(U)**.
- `buildTurnOrder`:
  - объединение списков: **O(U)**,
  - сортировка: **O(U log U)**.
- проход по `turnOrder` и вызовы атак: **O(U · A)**.

Итого:
- **O(R · (U log U + U · A))** в худшем случае.
- Память: список порядка хода **O(U)**.

---

## Краткое резюме по сложностям

- `GeneratePresetImpl`: **O(n log n + k·n)**, где `k ≤ 63` - практически **O(n log n)**.
- `SuitableForAttackUnitsFinderImpl`: **O(M)** (линейно по числу просмотренных юнитов).
- `UnitTargetPathFinderImpl` (A\*): **O(u + V log V)**, где `V = 567`.
- `SimulateBattleImpl`: **O(R · (U log U + U·A))**, `R ≤ 10000`.
